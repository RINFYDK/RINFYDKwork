From c5cb83280406f3bee153a748d5e3e94b8065ca6b Mon Sep 17 00:00:00 2001
From: Simon Chung <simon.c.chung@accenture.com>
Date: Fri, 26 Aug 2016 11:08:30 +0100
Subject: [PATCH] platform api

---
 source/platform/platform_hal.c | 341 +++++++++++++++++++++++++++++++++++------
 1 file changed, 292 insertions(+), 49 deletions(-)

diff --git a/source/platform/platform_hal.c b/source/platform/platform_hal.c
index b963113..dbe59fd 100644
--- a/source/platform/platform_hal.c
+++ b/source/platform/platform_hal.c
@@ -19,13 +19,13 @@
 
 /**********************************************************************
    Copyright [2014] [Cisco Systems, Inc.]
- 
+
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
- 
+
        http://www.apache.org/licenses/LICENSE-2.0
- 
+
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -37,7 +37,43 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "platform_hal.h" 
+#include "platform_hal.h"
+
+#define MAX_BUFFER_SIZE     1024
+#define TMP_BUFFER_SIZE     128
+#define ONE_KILOBYTE        1024
+
+static int execute(char *command, char *result)
+{
+    FILE *fp = NULL;
+    char output[MAX_BUFFER_SIZE] = {0};
+    char *str = NULL;
+
+    fp = popen(command, "r");
+    if(NULL == fp)
+    {
+        printf("Failed to run command\n" );
+        return RETURN_ERR;
+    }
+
+    /* only the first line of the output is of interest */
+    fgets(output, sizeof(output)-1, fp);
+    str = strstr(output, ":");
+
+    if(NULL != str)
+    {
+        strcpy(result, (str + 1));
+    }
+    else
+    {
+        strcpy(result,output);
+    }
+
+    printf("\nresult = %s\n", result);
+    pclose(fp);
+
+    return RETURN_OK;
+}
 
 /* Note that 0 == RETURN_OK == STATUS_OK    */
 /* Note that -1 == RETURN_ERR == STATUS_NOK */
@@ -56,90 +92,297 @@ INT platform_hal_SetWebUITimeout(ULONG value) { return RETURN_ERR; }
 INT platform_hal_GetWebAccessLevel(INT userIndex, INT ifIndex, ULONG *pValue) { return RETURN_ERR; }
 INT platform_hal_SetWebAccessLevel(INT userIndex, INT ifIndex, ULONG value) { return RETURN_ERR; }
 
-INT platform_hal_PandMDBInit(void) { return RETURN_OK; }
+INT platform_hal_PandMDBInit(void)
+{
+    return RETURN_OK;
+
+}
 INT platform_hal_DocsisParamsDBInit(void) { return RETURN_OK; }
-INT platform_hal_GetModelName(CHAR* pValue) { strcpy(pValue, "Model Name"); return RETURN_OK; }
-INT platform_hal_GetSerialNumber(CHAR* pValue) { strcpy(pValue, "Serial Number"); return RETURN_OK; }
-INT platform_hal_GetHardwareVersion(CHAR* pValue) { strcpy(pValue, "Hardware Version"); return RETURN_OK; }
-INT platform_hal_GetSoftwareVersion(CHAR* pValue, ULONG maxSize) { strcpy(pValue, "Software Version"); return RETURN_OK; }
-INT platform_hal_GetBootloaderVersion(CHAR* pValue, ULONG maxSize) { strcpy(pValue, "Bootloader Version"); return RETURN_OK; }
-INT platform_hal_GetFirmwareName(CHAR* pValue, ULONG maxSize) { strcpy(pValue, "Firmware Name"); return RETURN_OK; }
+
+INT platform_hal_GetModelName(CHAR* pValue)
+{
+    char model[TMP_BUFFER_SIZE]= {'\0'};
+    int ret = RETURN_ERR;
+
+    if(NULL == pValue)
+    {
+        return RETURN_ERR;
+    }
+    ret = execute("grep 'model name' /proc/cpuinfo", model);
+    if(RETURN_OK != ret)
+    {
+        printf("\nError %s\n", __func__);
+    }
+    else
+    {
+        strncpy(pValue, model, strlen(model));
+    }
+
+    return ret;
+}
+
+INT platform_hal_GetSerialNumber(CHAR* pValue)
+{
+    char sn[TMP_BUFFER_SIZE] = {'\0'};
+    int ret = RETURN_ERR;
+
+    if(NULL == pValue)
+    {
+        return RETURN_ERR;
+    }
+    ret = execute("grep 'Serial' /proc/cpuinfo", sn);
+    if(RETURN_OK != ret)
+    {
+        printf("\nError %s\n", __func__);
+    }
+    else
+    {
+        strncpy(pValue, sn, strlen(sn));
+    }
+
+    return ret;
+}
+
+INT platform_hal_GetHardwareVersion(CHAR* pValue)
+{
+    if(NULL == pValue )
+    {
+        return RETURN_ERR;
+    }
+
+    strcpy(pValue, "");
+
+    return RETURN_OK;
+}
+
+INT platform_hal_GetSoftwareVersion(CHAR* pValue, ULONG maxSize)
+{
+    if(NULL == pValue )
+    {
+        return RETURN_ERR;
+    }
+
+    strcpy(pValue, "Not Supported");
+
+    return RETURN_OK;
+}
+
+INT platform_hal_GetBootloaderVersion(CHAR* pValue, ULONG maxSize)
+{
+    if(NULL == pValue )
+    {
+        return RETURN_ERR;
+    }
+
+    strcpy(pValue, "Bootloader Version");
+
+    return RETURN_OK;
+}
+
+INT platform_hal_GetFirmwareName(CHAR* pValue, ULONG maxSize)
+{
+    char fn[TMP_BUFFER_SIZE] = {'\0'};
+    int ret = RETURN_ERR;
+
+    if(NULL == pValue )
+    {
+        return RETURN_ERR;
+    }
+    ret = execute("grep 'imagename' /version.txt", fn);
+    if(RETURN_OK != ret)
+    {
+        printf("\nError %s\n", __func__);
+    }
+    else
+    {
+        strncpy(pValue, fn, strlen(fn));
+    }
+
+    return ret;
+}
+
+
 INT platform_hal_GetBaseMacAddress(CHAR *pValue) { strcpy(pValue, "BasMac"); return RETURN_OK; }
-INT platform_hal_GetHardware(CHAR *pValue) { strcpy(pValue, "Hard"); return RETURN_OK; }
-INT platform_hal_GetTotalMemorySize(ULONG *pulSize) { *pulSize = 512*1024; return RETURN_OK; }
+INT platform_hal_GetHardware(CHAR *pValue)
+{
+    int ret = RETURN_ERR;
+    char hwVer[TMP_BUFFER_SIZE] = {'\0'};
 
-INT platform_hal_GetHardware_MemUsed(CHAR *pValue)
+    if(NULL == pValue)
+    {
+        return RETURN_ERR;
+    }
+
+    ret = execute("grep 'Revision' /proc/cpuinfo", hwVer);
+    if(RETURN_OK != ret)
+    {
+        printf("\nError %s\n", __func__);
+    }
+    else if(strstr(hwVer, "a02082") != NULL)
+    {
+        strncpy(pValue, "raspberrypi3", strlen("raspberrypi3"));
+    }
+    else if(strstr(hwVer, "a01041") != NULL)
+    {
+        strncpy(pValue, "raspberrypi2", strlen("raspberrypi2"));
+    }
+    else
+    {
+        strncpy(pValue, "raspberrypi", strlen("raspberrypi"));
+    }
+
+    return ret;
+
+}
+INT platform_hal_GetTotalMemorySize(ULONG *pulSize)
 {
-    if (pValue == NULL)
+    char totMem[TMP_BUFFER_SIZE] = {'\0'};
+    int ret = RETURN_ERR;
+
+    if(NULL == pulSize)
     {
         return RETURN_ERR;
     }
+
+    ret = execute("grep 'MemTotal' /proc/meminfo", totMem);
+    if(RETURN_OK != ret)
+    {
+        printf("\nError %s\n", __func__);
+    }
     else
     {
-	*pValue='0';
-        return RETURN_OK;
+        sscanf(totMem, "%d", pulSize );
+     *pulSize = *pulSize/ONE_KILOBYTE;
     }
+
+    return ret;
 }
 
-INT platform_hal_GetHardware_MemFree(CHAR *pValue)
+INT platform_hal_GetHardware_MemUsed(CHAR *pValue)
 {
-    if (pValue == NULL)
-    {   
+    char usedMem[TMP_BUFFER_SIZE]={'\0'};
+    int ret = RETURN_ERR;
+    long tmp;
+
+    if(NULL == pValue)
+    {
         return RETURN_ERR;
     }
+
+    ret = execute("df | grep '/dev' | awk '{print $3}'", usedMem);
+    if(RETURN_OK != ret)
+    {
+        printf("Error: %s", __func__);
+    }
     else
     {
-	*pValue='0';
-        return RETURN_OK;
+        tmp = atoi(usedMem)/ONE_KILOBYTE;
+        sprintf(pValue, "%ld",  tmp);
     }
+
+    return ret;
+}
+
+
+INT platform_hal_GetHardware_MemFree(CHAR *pValue)
+{
+   char freeMem[TMP_BUFFER_SIZE] = {'\0'};
+   int ret = RETURN_ERR;
+   long tmp;
+
+   if(NULL == pValue)
+   {
+       return RETURN_ERR;
+   }
+   ret = execute("df | grep '/dev' | awk '{print $4}'", freeMem);
+   if(RETURN_OK != ret)
+   {
+       printf("Error:%s", __func__);
+   }
+   else
+   {
+      tmp = atoi(freeMem)/ONE_KILOBYTE;
+      sprintf(pValue, "%ld", tmp);
+   }
+
+   return ret;
 }
 
 INT platform_hal_GetFreeMemorySize(ULONG *pulSize)
 {
-        if (pulSize == NULL)
-        {
-           return RETURN_ERR;
-        }
-        *pulSize = 0;
-        return RETURN_OK;
+    char freeMem[TMP_BUFFER_SIZE] = {'\0'};
+    int ret = RETURN_ERR;
+
+    if(NULL == pulSize)
+    {
+        return RETURN_ERR;
+    }
+
+    ret = execute("free| grep 'Mem'| awk '{print $4}'", freeMem);
+    if(RETURN_OK != ret)
+    {
+        printf("Error:%s", __func__);
+    }
+    else
+    {
+        *pulSize = atoi(freeMem)/ONE_KILOBYTE;
+    }
+
+    return ret;
 }
 
 INT platform_hal_GetUsedMemorySize(ULONG *pulSize)
 {
-        if (pulSize == NULL)
-        {
-           return RETURN_ERR;
-        }
-        *pulSize = 0;
-        return RETURN_OK;
+    int ret = RETURN_ERR;
+    char usedMem[TMP_BUFFER_SIZE] = {'\0'};
+    int tmp;
+
+    if(NULL == pulSize)
+    {
+        return RETURN_ERR;
+    }
+
+    ret = execute("free| grep 'Mem'| awk '{print $3}'", usedMem);
+    if(RETURN_OK != ret)
+    {
+        printf("Error: %s", __func__);
+    }
+    else
+    {
+        *pulSize = atoi(usedMem)/ONE_KILOBYTE;
+    }
+
+    return ret;
 }
 
 INT platform_hal_GetFactoryResetCount(ULONG *pulSize)
 {
-        if (pulSize == NULL)
-        {
-           return RETURN_ERR;
-        }
-        *pulSize = 2;
-        return RETURN_OK;
+    if(NULL == pulSize)
+    {
+        return RETURN_ERR;
+    }
+
+    *pulSize = 2;
+
+    return RETURN_OK;
 }
 
 INT platform_hal_ClearResetCount(BOOLEAN bFlag)
 {
-        return RETURN_OK;
+    return RETURN_OK;
 }
 
 INT platform_hal_getTimeOffSet(CHAR *pValue)
-{ 
-	return RETURN_OK; 
-} 
+{
+    return RETURN_OK;
+}
 
 INT platform_hal_SetDeviceCodeImageTimeout(INT seconds)
-{ 
-	return RETURN_OK; 
-} 
+{
+    return RETURN_OK;
+}
 
 INT platform_hal_SetDeviceCodeImageValid(BOOLEAN flag)
-{ 
-	return RETURN_OK; 
+{
+    return RETURN_OK;
 }
-- 
2.8.3

